/*
 * Copyright (c) 2014 mgm technology partners GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import com.mgmtp.perfload.supervisor.Commands
import com.mgmtp.perfload.supervisor.SupervisorTasks
import com.mgmtp.perfload.supervisor.SupervisorUtils
import org.apache.commons.io.FilenameUtils
import org.apache.commons.lang3.StringUtils
import org.apache.commons.lang3.time.StopWatch

import java.text.DateFormat
import java.text.SimpleDateFormat
import java.util.Collections
import java.util.regex.Matcher

buildscript {
	dependencies {
		classpath fileTree(dir: 'lib')
	}
}

defaultTasks 'runLoadTest'

def config() {
	project.ext {
		if (!project.hasProperty('tenant')) {
			tenant = System.getenv('PERFLOAD_TENANT')
		}

		if (!project.hasProperty('system')) {
			system = System.getenv('PERFLOAD_SYSTEM')
		}

		supervisorConfig = SupervisorUtils.loadConfig(tenant, 'SupervisorConfig.groovy')
		commands = SupervisorUtils.loadConfig(Commands.class)

		loadTestConfig = null  // loadTestConfig can only be determined after we have chosen the testplan to use
		supervisorTasks = new SupervisorTasks(ant: ant, loadTestConfig: loadTestConfig, commands: commands)

		resultsDir = "$projectDir/results"
		consoleDir = "$projectDir/../console"
		perfAlyzerDir = "$projectDir/../perfalyzer"

		if (!supervisorConfig.requireTestComment) {
			testComment = ''
		}
	}
}

def welcome() {
	String msgTemplate = getClass().getResource('/supervisor-msg.txt').getText('UTF-8')
	int len = 60

	println msgTemplate
			.replace('@msg1@', '(c) 2013 - 2017, mgm technology partners GmbH'.center(len))
			.replace('@msg2@', 'Welcome to perfLoad\'s Supervisor ${project.version}'.center(len))

	println()

	if (tenant) {
		println "Running in multi-tenancy mode. Tenant: $tenant."
	} else {
		println 'No tenant specified. Running in single-tenancy mode.'
	}
	
	if (system) {
		println "Running in multi-system mode. System: $system."
	} else {
		println 'No system specified. Running in single-system mode.'
	}	

	println()
	println()
}

task init(description: 'Initializes the Supervisor loading basic configuration for testplan-independent tasks') {
	config()
	welcome()
}

task loadTestplan(description: 'Loads the test plan possibly prompting for the testplan to be used.') << {
	// if not set via command-line (-Ptestplan=<...>), the user is prompted for the test config to be used
	if (!project.hasProperty('testplan')) {
		project.ext.testplan = promptForTestplan()
	}

	// Use the testplan file's base name as the test name and add it to the script's binding.
	// Thus, it is also accessible by an included 'ProjectTargets.gradle' file.
	project.ext.testname = FilenameUtils.getBaseName(testplan)

	// prefix the results directory with a timestamp
	DateFormat df = new SimpleDateFormat('yyyyMMdd-HHmm')

	def dateString = project.hasProperty('testDate') ? testDate : df.format(new Date())
	def testResultsDir = new File(resultsDir, "${tenant ? tenant + '/' : ''}${dateString}_${FilenameUtils.getBaseName(testplan)}")

	project.ext.testResultsDir = testResultsDir
	// sys prop necessary for logging to file, used in init.gradle
	System.setProperty('testResultsDir', testResultsDir.path)

	testResultsDir.mkdirs()
	supervisorTasks.resultsDir = testResultsDir

	// set the LoadTestConfig - possibly depending on the tenant and system 
	String loadTestConfigFilename = buildConfigFileName(system, 'LoadTestConfig', '.groovy', testplan)
	loadTestConfig = SupervisorUtils.loadTestConfig(tenant, loadTestConfigFilename)
	println "Using loadTestConfig: $loadTestConfigFilename"
	supervisorTasks.loadTestConfig = loadTestConfig
	
	// if it's use is enabled, then set the ProjectSpecificTasks - possibly depending on the tenant and system
	if (supervisorConfig.runProjectSpecificTasks) {
		String projectTasksFilename = buildConfigFileName(system, 'ProjectTasks', '.gradle', testplan)
		String projectTasks = "conf/${tenant ? tenant + '/' : ''}$projectTasksFilename"
		println "Including project tasks file: $projectTasks"
		// includes project-specific tasks as if they were directly defined in this file
		apply from: projectTasks
	}
}

task runLoadTest(dependsOn: loadTestplan, description: 'Runs a load test.') << {
	// if not set via command-line (-DtestComment=<...>), the user is prompted for the test config to be used
	if (!project.hasProperty('testComment')) {
		project.ext.testComment = new Console().readLine('\nPlease enter some comment for the test:')
	}

	def tasks = []

	if (supervisorConfig.cleanupBeforeTest) {
		tasks << cleanupFiles
	}

	if (supervisorConfig.runProjectSpecificTasks) {
		tasks << before
	}

	tasks << startPerfmons
	tasks << restartDaemons

	if (supervisorConfig.executeStartupCommands) {
		tasks << executeStartupCommands
	}

	if (supervisorConfig.runProjectSpecificTasks) {
		tasks << performSystemCheck
	}

	tasks << startTest

	if (supervisorConfig.executeShutdownCommands) {
		tasks << executeShutdownCommands
	}

	tasks << stopDaemons
	tasks << stopPerfmons

	tasks << createTransferDirs

	if (supervisorConfig.runProjectSpecificTasks) {
		tasks << after
	}

	task writeTestComment << {
		new File(consoleDir, 'perfload.meta.utf8.props').withWriterAppend('UTF-8') { writer ->
			new PrintWriter(writer).println("test.comment=${testComment}")
		}
	}
	tasks << writeTestComment

	if (supervisorConfig.collectResults) {
		tasks << archiveFiles
		tasks << downloadFiles
	}

	if (supervisorConfig.createReport) {
		tasks << runPerfAlyzer
	}

	StopWatch stopWatch = new StopWatch()
	stopWatch.start()

	tasks.each { it.execute() }

	stopWatch.stop()

	println()
	println 'LOAD TEST EXECUTION FINISHED'
	println()
	println "Total execution time: $stopWatch"
}

task startTest(dependsOn: loadTestplan, description: 'Starts a load test') << {
	List daemons = SupervisorUtils.readDaemonsFromConfig(loadTestConfig)
	SupervisorUtils.executeCommandLine("./console", consoleDir,
			[
					'-testplan',
					testplan,
					'-daemons',
					daemons.join(','),
					'-timeout',
					"${supervisorConfig.loadProfileTestTimeout}"
			].flatten())
}

task abortLoadTest(dependsOn: loadTestplan, description: 'Aborts a load test') << {
	List daemons = SupervisorUtils.readDaemonsFromConfig(loadTestConfig)
	SupervisorUtils.executeCommandLine("./console", consoleDir,
			[
					'-testplan',
					testplan,
					'-daemons',
					daemons.join(','),
					'-abort'
			].flatten())
}

task runPerfAlyzer(dependsOn: loadTestplan, description: 'Run perfAlyzer to create the report') << {
	String absoluteResultsDir = testResultsDir.getAbsolutePath()

	SupervisorUtils.executeCommandLine("./perfalyzer", perfAlyzerDir,
			[
					'-i',
					absoluteResultsDir,
					'-o',
					"output${tenant ? '/' + tenant : ''}"
			])
}

task startDaemons(description: 'Starts daemons') << { supervisorTasks.startDaemons() }

task stopDaemons(description: 'Stops daemons') << { supervisorTasks.stopDaemons() }

task restartDaemons(description: 'Restart daemons') << {
	supervisorTasks.stopDaemons()
	sleep 5000L
	supervisorTasks.startDaemons()
}

task startPerfmons(description: 'Starts perfmons') << { supervisorTasks.startPerfmons() }

task stopPerfmons(description: 'Stops perfmons') << { supervisorTasks.stopPerfmons() }

task cleanupFiles(description: 'Perform all clean-up tasks.') << {
	cleanupConsoleFiles()
	supervisorTasks.cleanupDaemonFiles()
	supervisorTasks.cleanupClientFiles()
	supervisorTasks.cleanupPerfmonFiles()
	supervisorTasks.cleanupConfiguredFiles()
}

task createTransferDirs(description: 'Creates transfer directories') << { supervisorTasks.createTransferDirs() }

task executeStartupCommands(description: 'Executes configured startup commands') << { supervisorTasks.execStartupCommands() }

task executeShutdownCommands(description: 'Executes configured shutdown commands') << { supervisorTasks.execShutdownCommands() }

task archiveFiles(dependsOn: loadTestplan, description: 'Archives all result files via SSH') << {
	archiveConsoleFiles()
	supervisorTasks.archiveDaemonLogs()
	supervisorTasks.archiveClientLogs()
	supervisorTasks.archivePerfmonLogs()
	supervisorTasks.archiveConfiguredFiles()
}

task downloadFiles(dependsOn: loadTestplan, description: 'Downloads all result files via SCP.') << {
	supervisorTasks.downloadDaemonLogs()
	supervisorTasks.downloadClientLogs()
	supervisorTasks.downloadPerfmonLogs()
	supervisorTasks.downloadConfiguredFiles()
}

task listTestplans(description: 'Display a list of available testplans') << {
	List<String> testplans = readTestplans(tenant)
	println listTestplans(testplans)
}

def String promptForTestplan() {
	List<String> testplans = readTestplans(tenant, system)
	
	String lineSep = System.properties.'line.separator'
	String prompt = "${lineSep}Please select the testplan you'd like to use:$lineSep"
	prompt += listTestplans(testplans)

	// display all configured testplans prefixed by running numbers,
	// which the user needs to enter in order to select the desired testplan
	while (true) {
		def testplanIndex = new Console().readLine(prompt)
		int index

		try {
			index = Integer.parseInt(testplanIndex) - 1
			if (index < 0 || index >= testplans.size()) {
				continue
			}
		} catch (NumberFormatException ex) {
			continue
		}

		def selectedTestplan = testplans[index]

		println()
		println "Selected testplan: '$selectedTestplan'..."
		println()

		return "${tenant ? tenant + '/' : ''}$selectedTestplan"
	}
}

/**
 * Retrieves all testplans from the perfLoad console's testplan directory that match the previously set tenant and system.
 * 
 * Possible cases:
 * - If neither a tenant nor a system are set, then simply all XML-files from the console's testplan directory are returned.
 * - If a tenant 'x' is set, but no system, then all XML-files from the console's testplan directory in the subfolder 'x' are
 *   returned.
 * - If a system 'y' is set, but no tenant, then all  XML-files from the console's testplan directory whose filenames match the
 *   pattern '_y.xml' are returned.
 * - if both a tenant 'x' and a system 'y' are set,  then all XML-files from the console's testplan directory in the subfolder 'x'
 *   are returned, whose filenames match the pattern '_y.xml'.
 * 
 * @param tenant the tenant of the load test
 * @param system the system that the load test should be executed against
 * @return all matching testplans, or an empty list if no testplans could be retrieved
 * 
 */
def List<String> readTestplans(String tenant, String system) {
	List<String> testplans = []
	List<String> complementaryTestplans = []
	File testplanDir = new File(consoleDir, "testplans/${tenant ? tenant : ''}")

	String systemSuffices = readSystemSufficesPattern(tenant)
	def systemSufficesPattern = '(' + (systemSuffices ? systemSuffices + '|' : '')  + 'shared|SHARED)'
	if (system) {
		if (system.equals('ALL') || system.equals('all') ) {
			testplanDir.eachFileMatch(~/.+?_${systemSufficesPattern}\.xml/, { testplans << it.name })
		} else {
			def specificSystemPattern = '(' + system + '|shared|SHARED)'
			testplanDir.eachFileMatch(~/.+?_${specificSystemPattern}\.xml/, { testplans << it.name })
		}
	} else {
		testplanDir.eachFileMatch(~/.+?_${systemSufficesPattern}\.xml/, { complementaryTestplans << it.name })
		testplanDir.eachFileMatch(~/.+?\.xml/, {
			if (!complementaryTestplans.contains(it.name)) { testplans << it.name }
		})
	}
	if(testplans.isEmpty()) {
		throw new GradleException('No testplans are available for the given combination of tenant and system.')
	}
	Collections.sort(testplans)
	testplans
}

/**
 * Retrieves all system-specific suffices from the load test configuration files, possibly for a given tenant.
 * If a tenant 'x' is provided, then files in the subfolder 'x' of the perfLoad supervisor's 'conf' folder
 * are traversed, otherwise the files in the 'conf' folder itself are traversed.
 * 
 * Example:
 * Let us say there are three files in the folder 'conf/x', namely 'LoadTestConfig.groovy', 'LoadTestConfig_QA.groovy'
 * and 'LoadTestConfig_PROD.groovy', then the method will return a list containing the strings 'QA' and 'PROD'.  
 * 
 * @param tenant the tenant of the load test
 * @return all matching system-suffices, or an empty list if no system-suffices could be retrieved
 * 
 */
def String readSystemSufficesPattern(String tenant) {
	List<String> systemSuffices = []
	new File('.', "conf/${tenant ? tenant : ''}").eachFileMatch(~/LoadTestConfig_.+\.groovy/, {
		systemSuffices << (it.name =~ ~/LoadTestConfig_(.+)\.groovy/)[0][1]
	})
	systemSuffices.join('|')
}

def String listTestplans(List<String> testplans) {
	String lineSep = System.properties.'line.separator'
	int i = 1
	testplans.collect { "${StringUtils.leftPad(String.valueOf(i++), 3)}) $it" }.join(lineSep) + lineSep
}

/**
 * Builds a (possibly system-specific) config filename from the given system or testplan information.
 * 
 * Possible cases:
 * - If no system is set, then simply a concatenation of the base filename and the ending is returned, e.g.: LoadTestConfig.groovy  
 * - If system is set to generic value 'ALL', then the system suffix of the config file must be retrieved from the previously 
 *   chosen testplan, e.g.: testplan_x.xml -> LoadTestConfig_x.groovy
 * - If a system 'y' is set, then the config file will contain the respective system suffix, e.g. LoadTestConfig_y.groovy
 * 
 * @param system the system that the load test should be executed against
 * @param configFileBaseName the base filename of the config file to build, i.e. without system or filetype suffix
 * @param configFileSuffix the filetype suffix of the config file to build 
 * @param testplan the testplan that has previously been chosen
 * @return the config filename that was build from the system information provided
 * 
 */
def String buildConfigFileName(String system, String configFileBaseName, String configFileSuffix, String testplan) {
	String configFileName = null
	if (system) {	// multi-system mode
		if (system == 'ALL' || system == 'all') {  // ... the specific system to use is implicitly determined by the testplan
			String testplanBaseName = FilenameUtils.getBaseName(testplan)
			Matcher matcher = testplanBaseName =~ /_([^_]+)$/
			assert matcher[0] != null, "Could not retrieve a 'system' suffix from testplan base name"
			configFileName = configFileBaseName + '_' + matcher[0][1] + configFileSuffix
		} else {	// ... the specific system was already set in advance
			configFileName = configFileBaseName + '_' + system + configFileSuffix
		}
	} else {	// single-system mode
		configFileName = configFileBaseName + configFileSuffix
	}
	configFileName
}

def archiveConsoleFiles() {
	File testplanFile = new File("${consoleDir}/testplans/${testplan}")
	def config = new XmlSlurper().parse(testplanFile)
	String eventsFile = config.loadProfile

	task(archiveConsoleFiles, type: Zip) {
		from(consoleDir) {
			include '*.log'
			include 'ltStatus.txt'
			include 'ltThreads.txt'
			include 'perfload.meta.utf8.props'
		}
		from(testplanFile.parent) { include testplanFile.name }
		from("${testplanFile.parent}/loadprofiles") { include eventsFile }
		archiveName = "console-logs.zip"
		destinationDir = file("${testResultsDir}/console")
	}.execute()
}

def cleanupConsoleFiles() {
	ant.delete {
		fileset(dir: "${consoleDir}") {
			include(name: '*.log')
			include(name: 'ltStatus.txt')
			include(name: 'ltThreads.txt')
			include(name: 'perfload.meta.utf8.props')
		}
	}
}

class Console {

	private final java.io.Console console
	private BufferedReader oldFashionedReader

	Console() {
		console = System.console()
		if (console == null) {
			oldFashionedReader = new BufferedReader(new InputStreamReader(System.in))
		}
	}

	String readLine(String prompt) {
		if (console != null) {
			return console.readLine(prompt)
		} else {
			try {
				println(prompt)
				return oldFashionedReader.readLine()
			} catch (IOException ex) {
				// can't really happen
				throw new UncheckedIOException(ex)
			}
		}
	}
}
